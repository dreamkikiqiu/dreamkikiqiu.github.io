---
title: 哈希表、有序表、比较器[算法新手的入门教程]
published: 2024-10-24
description: ''
image: '/guild/demo_post1.jpg'
tags: [hashtable]
category: '数据结构与算法【Java】'
draft: true
lang: 'zh_CN'
---

### 前置知识和介绍
- **前置知识：没有。**
- 曾经我刷算法题曾苦于哈希表久矣。 因为，总觉得不理解哈希表原理，那么我始终“畏惧”使用哈希表这种数据结构。网上帖子大多是上了给你一堆粗糙庞大模糊的概念， 哈希函数，哈希碰撞，链式哈希，开放寻址，直接寻址表， 又有说法哈希表是数组链表红黑树的结合。然后，又去查了一下红黑树， 彻底劝退了。
- **前期， 我们应该忽略哈希表的内部底层细节， 学会如何使用才是关键。 后期，数据结构有了经验和能力可以完整学习哈希表数据结构和哈希算法等等**
写下此篇，一方面回顾自己的使用细节， 另一方面帮助需要的朋友们快速入门哈希表并将它们应用在算法题的练习上。

- **最后，本篇虽然以Java语言介绍，但任意语言有对等的概念。比如C++中哈希表，有序表的概念，python中的字典等。遗憾地是，C语言必须自己实现一个哈希表（亦或者找到别人造好的轮子使用）**

### 哈希表
首先介绍Java中内置哈希表`HashSet`,`HashMap`。
这里必须了解key的概念， 下面会以数组开始引入"key"的概念。
先回顾一下数组的知识:
哈希表是普通数组的推广， 一般地，我们知道普通数组可以直接寻址（通过索引也就是下标）可以快速访问数组元素。比如给定一个长度为`n`的数组，那么索引范围是`[0,n-1]`， 数组中作索引的永远是一个该范围的整数。
那么，有没有一种“魔法”，可以让这个索引变得更广泛。比如，我要用字符串作索引呢？
我用一个浮点数而不是整数，还可以用字符，甚至对象呢？
哈希表就是这个魔法。
key就是哈希表中索引的统称， 它被称之为键的东西。功能上，它等同于数组的下标。
类型？由你决定，它可以是任意类型（Java实现了泛型机制）。

Java中哈希表有两种形式，一种是HashSet,还要HashMap。
下面依次介绍HashSet和HashMap。
#### 1. HashSet
- **key在哈希表中存储两种形式， 一种是以值形式存储，另一种是对象的内存地址（这表明key执行某个对象的实际内存位置）。**

- HashSet它不关心key对应的值是什么，只关心key是否存在。
举个比方:
`boolean[] visit = new boolean[10];`
10个空间的布尔数组，比如查询下标为1的数组元素是否存在？它返回false或者true。至于下标1的元素到底是什么，我们不关心。这个好比，如果我们关心值是什么，取决于值的类型，就使用了int类型，double,char类型。这种反应了值的具体类型，而不是一个布尔类型。
比如，我们只关心一段文本中，某个单词是否出现，而不是其它的（这个单词出现了多少次）等问题。我们就使用HashSet,把它想象成布尔数组。它可以有效节约内存，根据问选择是否使用HashSet?

`结合上面的两点用代码举例:`

Java中的8大基本类型（8大包装类）和字符串类型都是根据值类型比较的。
```
	//Integer, Long, Byte, Short 整型
	//Float, Double	浮点型
	//Boolean	布尔型
	//Character 字符型
	//String 字符串类型
```

你可能疑问String类:
```java
public static void main(String[] args) {
		String str1 = new String("hello");
		String str2 = new String("hello");
		
		System.out.println(str1 == str2);
		System.out.println(str1.equals(str2));
}
/**
 * output:
 * false
 * true
 * /
```
- str1 和 str2尽管字面值是一样的， 但是由于String类是引用类型。str1,str2实际引用的实际对象的地址。 因此不能用==比较，而是改用equals方法判断两个字符串是否相等。
- **现在请记住，对于哈希表包括后面的有序表，字符串就是按“值”比较的，具体原因和细节留待日后对于字符串哈希算法的学习。**

##### HashSet使用

需要前置导入: `import java.util.HashSet;`
`HashSet<String> set = new HashSet<>();`
HashSet后面的菱形语句可以指定一个类型， 这里就以String类型举例。
```java
public static void main(String[] args) {
		String str1 = new String("hello");
		String str2 = new String("hello");
		
		//创建一个HashSet
		HashSet<String> set = new HashSet<>();
		//将str1加入表中
		set.add(str1);
		//查询str1是否在表中
		System.out.println(set.contains(str1));
		//查询str2是否在表中
		System.out.println(set.contains(str2));
		//将str2加入表中
		set.add(str2);
		//查看表内大小
		System.out.println(set.size());
		//移除表中元素str1
		set.remove(str1);
		//清空哈希表
		set.clear();
		//判断哈希表是否为空。
		System.out.println(set.isEmpty());
	}
	/**
	 * output：
	 * true
	 * true
	 * 1
	 * true
	 */
```
再次强调，HashSet中key存储String都是字面值。
`set.add(str1);`这句话是将str1中的"hello"作为key

### 有序表

### 比较器使用